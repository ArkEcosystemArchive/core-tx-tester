"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@arkecosystem/crypto");
const bytebuffer_1 = __importDefault(require("bytebuffer"));
const enums_1 = require("../enums");
const entity_schemas_1 = require("./utils/entity-schemas");
const { schemas } = crypto_1.Transactions;
class EntityTransaction extends crypto_1.Transactions.Transaction {
    static getSchema() {
        const baseAssetDataProps = {
            type: { type: "integer", minimum: 0, maximum: 255 },
            subType: { type: "integer", minimum: 0, maximum: 255 },
            registrationId: { $ref: "transactionId" },
        };
        return schemas.extend(schemas.transactionBaseSchema, {
            $id: "entity",
            required: ["asset", "typeGroup"],
            properties: {
                type: { transactionType: enums_1.MagistrateTransactionType.Entity },
                typeGroup: { const: enums_1.MagistrateTransactionGroup },
                amount: { bignumber: { minimum: 0, maximum: 0 } },
                asset: {
                    type: "object",
                    anyOf: [
                        {
                            required: ["type", "subType", "action", "data"],
                            additionalProperties: false,
                            properties: {
                                ...baseAssetDataProps,
                                action: { const: enums_1.EntityAction.Register },
                                data: entity_schemas_1.register,
                            },
                        },
                        {
                            required: ["type", "subType", "action", "data", "registrationId"],
                            additionalProperties: false,
                            properties: {
                                ...baseAssetDataProps,
                                action: { const: enums_1.EntityAction.Resign },
                                data: entity_schemas_1.resign,
                            },
                        },
                        {
                            required: ["type", "subType", "action", "data", "registrationId"],
                            additionalProperties: false,
                            properties: {
                                ...baseAssetDataProps,
                                action: { const: enums_1.EntityAction.Update },
                                data: entity_schemas_1.update,
                            },
                        },
                    ],
                },
            },
        });
    }
    static staticFee(feeContext = {}) {
        // there should always be a feeContext.data except for tx builder when setting default fee in constructor
        return feeContext.data ? this.staticFeeByAction[feeContext.data.asset.action] : this.defaultStaticFee;
    }
    serialize() {
        const { data } = this;
        const asset = data.asset;
        const buffer = new bytebuffer_1.default();
        buffer.writeUint8(asset.type);
        buffer.writeUint8(asset.subType);
        buffer.writeUint8(asset.action);
        const registrationIdBuffer = Buffer.from(asset.registrationId || "", "hex");
        buffer.writeUint8(registrationIdBuffer.length);
        buffer.append(registrationIdBuffer, "hex");
        const nameBuffer = Buffer.from(asset.data.name || "");
        buffer.writeUint8(nameBuffer.length);
        buffer.append(nameBuffer);
        const ipfsDataBuffer = Buffer.from(asset.data.ipfsData || "");
        buffer.writeUint8(ipfsDataBuffer.length);
        buffer.append(ipfsDataBuffer);
        return buffer;
    }
    deserialize(buf) {
        const { data } = this;
        data.asset = {};
        data.asset.type = buf.readUint8();
        data.asset.subType = buf.readUint8();
        data.asset.action = buf.readUint8();
        const registrationIdBufferLength = buf.readUint8();
        if (registrationIdBufferLength > 0) {
            data.asset.registrationId = buf.readBytes(registrationIdBufferLength).toString("hex");
        }
        data.asset.data = {};
        const nameBufferLength = buf.readUint8();
        if (nameBufferLength > 0) {
            data.asset.data.name = buf.readString(nameBufferLength);
        }
        const ipfsDataBufferLength = buf.readUint8();
        if (ipfsDataBufferLength > 0) {
            data.asset.data.ipfsData = buf.readString(ipfsDataBufferLength);
        }
    }
}
exports.EntityTransaction = EntityTransaction;
EntityTransaction.typeGroup = enums_1.MagistrateTransactionGroup;
EntityTransaction.type = enums_1.MagistrateTransactionType.Entity;
EntityTransaction.key = "entity";
EntityTransaction.version = 2;
EntityTransaction.staticFeeByAction = {
    [enums_1.EntityAction.Register]: crypto_1.Utils.BigNumber.make(enums_1.MagistrateTransactionStaticFees.EntityRegister),
    [enums_1.EntityAction.Update]: crypto_1.Utils.BigNumber.make(enums_1.MagistrateTransactionStaticFees.EntityUpdate),
    [enums_1.EntityAction.Resign]: crypto_1.Utils.BigNumber.make(enums_1.MagistrateTransactionStaticFees.EntityResign),
};
EntityTransaction.defaultStaticFee = crypto_1.Utils.BigNumber.make(enums_1.MagistrateTransactionStaticFees.EntityRegister);
//# sourceMappingURL=entity.js.map